---
title: "Memory Type Deep Dive: ToolCall — The Immutable Audit Trail for Agent Actions"
description: "How OMS ToolCall grains record every tool invocation, argument, and result as an immutable, content-addressed record — enabling replay, debugging, cost tracking, and compliance."
date: "2026-02-19"
readTime: "10 min read"
tags: ["memory-types", "tool-calls", "audit", "function-calling"]
---

Every modern AI agent interacts with the world through tools. It searches the web, queries databases, calls APIs, writes files, sends messages. Each of these actions has consequences — sometimes irreversible ones. Yet in most agent frameworks today, tool invocations vanish into logs that are unstructured, mutable, and disconnected from the agent's memory.

The Open Memory Specification addresses this with a dedicated memory type: **ToolCall**. Defined in Section 8.5 of the OMS v1.0 specification, a ToolCall grain is an immutable, content-addressed record of a single tool invocation — what was called, with what arguments, what came back, and whether it succeeded. Every invocation is a separate grain, never modified after creation.

This post covers the ToolCall schema in detail, its field compaction keys, the parent task hierarchy mechanism, and real-world applications from API auditing to agent benchmarking.

## What Is a ToolCall Grain?

A ToolCall grain is a **record of tool/function invocation and result**. It captures the complete lifecycle of a single tool call: the tool's name, the arguments passed to it, the result it returned, and whether it succeeded or failed.

Unlike a log line that might read `"Called search API with query='climate data'"`, a ToolCall grain is a structured, binary-serialized, content-addressed object. It has a deterministic SHA-256 hash. It can be cryptographically signed. It can be referenced by other grains — a Goal grain can point to ToolCall grains as satisfaction evidence, or an Episode grain can reference the tool calls that occurred during a conversation.

In the OMS header, ToolCall grains carry type byte `0x05`. This means any system scanning a stream of `.mg` blobs can identify ToolCall grains by reading a single byte at offset 2 — no MessagePack deserialization required.

## Required Fields

Every ToolCall grain MUST include these six fields:

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Must be `"tool_call"` |
| `tool_name` | non-empty string | Name of the tool or function invoked |
| `arguments` | map | The arguments passed to the tool |
| `result` | any (MessagePack-serializable) | The value returned by the tool |
| `success` | bool | Whether the invocation succeeded |
| `created_at` | int64 (epoch ms) | When the invocation occurred |

The `result` field is deliberately typed as "any MessagePack-serializable value." This means it can be a string, a number, a map, an array, or even a nested structure — whatever the tool actually returned. OMS does not impose a schema on tool results because tools are inherently diverse.

The `success` field is a simple boolean. It does not encode partial success or degree of completion — those semantics belong in the `result` or `error` fields. A ToolCall either succeeded or it did not.

## Optional Fields

ToolCall grains support several optional fields that add context to the invocation record:

| Field | Type | Description |
|-------|------|-------------|
| `error` | string | Error message when `success=false` |
| `duration_ms` | int | Execution time in milliseconds |
| `author_did` | string | DID of the agent that made the call |
| `user_id` | string | Associated data subject (for GDPR) |
| `namespace` | string | Memory partition (default `"shared"`) |
| `parent_task_id` | string | Content address of a parent task grain |
| `structural_tags` | array[string] | Classification tags |
| `content_refs` | array[map] | References to external content |

The `error` field is only meaningful when `success` is `false`. It carries the error message — the raw string that describes what went wrong. This is distinct from `result`: a failed tool call might still return a result (like an HTTP error response body), while `error` captures the failure reason.

The `duration_ms` field records how long the tool invocation took in wall-clock milliseconds. This is a simple integer, not a float — millisecond precision is sufficient for tool call timing, and integers avoid the deterministic serialization complexities that floating-point values introduce.

## Field Compaction Keys

OMS uses field compaction to minimize blob size. Human-readable field names are mapped to short keys before serialization. The ToolCall-specific compaction keys, defined in Section 6.5, are:

| Full Name | Short Key | Type |
|-----------|-----------|------|
| `tool_name` | `tn` | string |
| `arguments` | `args` | map |
| `result` | `res` | any |
| `success` | `ok` | bool |
| `error` | `err` | string |
| `duration_ms` | `dur` | int |
| `parent_task_id` | `ptid` | string |

These compact keys are combined with the core field compaction (e.g., `type` becomes `t`, `created_at` becomes `ca`, `namespace` becomes `ns`). The mapping is bijective — one-to-one — and serializers MUST replace full names with short keys before encoding, while deserializers MUST reverse the mapping after decoding.

## Building Task Hierarchies with parent_task_id

The `parent_task_id` field is a content address (SHA-256 hash) pointing to a parent task grain. This simple reference enables building **task hierarchies** — a complex task that spawns sub-tool-calls.

Consider an agent tasked with "research and summarize recent papers on transformer architectures." This high-level task might decompose into:

1. A ToolCall to a search API to find papers
2. A ToolCall to a PDF extraction tool for each paper
3. A ToolCall to a summarization service
4. A ToolCall to format and store the final output

Each of these sub-tool-calls can set its `parent_task_id` to the content address of the overarching task grain. This creates a tree structure that can be traversed at query time to reconstruct the full execution flow.

Because `parent_task_id` is a content address, the reference is cryptographically verifiable. You can prove that a sub-task was associated with a specific parent by verifying the hash chain.

## A Concrete Example

Here is a complete ToolCall grain recording an API search, expressed in JSON before field compaction and binary serialization:

```json
{
  "type": "tool_call",
  "tool_name": "web_search",
  "arguments": {
    "query": "Open Memory Specification agent memory",
    "max_results": 10,
    "language": "en"
  },
  "result": {
    "results": [
      {
        "title": "OMS v1.0 Specification",
        "url": "https://memorygrain.org/spec",
        "snippet": "The Open Memory Specification defines the .mg container..."
      }
    ],
    "total_count": 42
  },
  "success": true,
  "duration_ms": 340,
  "created_at": 1737000000000,
  "namespace": "research",
  "author_did": "did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK",
  "structural_tags": ["api-call", "web-search"]
}
```

After field compaction, the payload keys become their short forms (`t`, `tn`, `args`, `res`, `ok`, `dur`, `ca`, `ns`, `adid`, `tags`), the map is sorted lexicographically, and the whole thing is serialized as canonical MessagePack. The 9-byte header is prepended: version `0x01`, flags byte, type byte `0x05` (ToolCall), the first two bytes of `SHA-256("research")` as the namespace hash, and the `created_at` epoch seconds as a 4-byte big-endian uint32. Finally, SHA-256 is computed over the complete blob to produce the content address.

The result is a single, self-contained binary object that can be stored, transmitted, verified, and referenced by hash.

## The Immutable Audit Trail

The fundamental property that makes ToolCall grains valuable for auditing is **immutability**. Each tool invocation creates a new grain. That grain is never modified — its content address is a SHA-256 hash of its bytes, and any change would produce a different hash.

This means:

- **No after-the-fact editing.** An agent cannot retroactively change what arguments it passed to a tool or what result it received.
- **No silent deletion.** While grains can be marked as superseded (via the `superseded_by` field), the original grain's bytes remain in storage, and its content address continues to resolve.
- **Cryptographic verification.** When a ToolCall grain is wrapped in a COSE Sign1 envelope (indicated by the `signed` flag in byte 1 of the header), a third party can verify both the integrity of the record and the identity of the agent that created it.

This produces a chain of tool invocations where every link is individually verifiable. If an agent claims it called a particular API with particular arguments, the ToolCall grain either exists with a valid content address or it does not.

## Industry Use Cases

### API Call Auditing

Every external API call an agent makes can be recorded as a ToolCall grain. This creates a complete audit trail: which APIs were called, with what parameters, what they returned, when, and by which agent. For organizations that need to demonstrate to regulators or auditors what their AI systems did and why, this is foundational.

The `author_did` field ties each call to a specific agent identity via a W3C Decentralized Identifier. The `namespace` field partitions calls by project, team, or environment. The `structural_tags` field enables classification — tagging calls as `"production"`, `"pii-access"`, or `"billing"` for targeted auditing.

### Debugging Agent Failures

When an agent fails, the most valuable debugging information is the exact sequence of tool calls leading up to the failure. With ToolCall grains, you can:

1. Filter grains by `author_did` and time range to isolate the agent's activity
2. Reconstruct the full execution trace via `parent_task_id` references
3. Inspect the exact `arguments` that were passed — not a summary, not a log approximation, but the actual serialized map
4. Examine the `result` and `error` fields to see what the tool returned
5. Replay the sequence by feeding the same arguments to the same tools

Because ToolCall grains store the actual arguments map and the actual result (any MessagePack-serializable value), replay is exact. There is no information loss between what happened and what was recorded.

### Cost Tracking and Billing

The `duration_ms` field enables straightforward cost attribution. If your organization bills for agent compute time or tracks API usage costs, you can aggregate `duration_ms` across ToolCall grains filtered by namespace, agent DID, or time range.

Combined with `structural_tags`, you can build cost breakdowns by category: how much time was spent on search calls versus database queries versus LLM inference. The immutability of grains means these numbers cannot be retroactively adjusted — they are what they are.

### Compliance Logging

Regulated industries need to prove what actions an AI agent took. Healthcare organizations subject to HIPAA, financial institutions under SOX, and any organization processing personal data under GDPR need verifiable records of automated actions.

ToolCall grains provide this by design:

- Each action is individually content-addressed and optionally signed
- The `user_id` field links actions to data subjects for GDPR right-of-access requests
- The `namespace` field enables partitioning by compliance domain
- The OMS sensitivity classification (bits 6-7 of the flags byte) can mark ToolCall grains as `pii` (binary `10`) or `phi` (binary `11`) at the header level, enabling O(1) filtering without payload deserialization

### Agent Benchmarking

ToolCall grains are a natural fit for measuring agent performance. Given a corpus of ToolCall grains from an agent's operation, you can compute:

- **Success rates:** Aggregate the `success` field across tools, time ranges, or namespaces
- **Latency distributions:** Analyze `duration_ms` to compute p50, p95, p99 latencies per tool
- **Error patterns:** Group failed calls by `error` message to identify systemic issues
- **Tool usage frequency:** Count grains per `tool_name` to understand agent behavior

Because every ToolCall is a separate, immutable grain, benchmarking data cannot be cherry-picked or retroactively filtered. The content-addressed nature means you can prove that a benchmark dataset has not been tampered with — the set of content addresses constitutes a verifiable manifest.

## ToolCall and the Broader Memory Graph

ToolCall grains do not exist in isolation. They participate in the broader OMS memory graph through several mechanisms:

- **Goal satisfaction evidence.** A Goal grain's `satisfaction_evidence` field is an array of content addresses pointing to ToolCall, Fact, or Observation grains that substantiate a `satisfied` state transition. This creates a verifiable link between "what the agent was trying to achieve" and "what the agent actually did."
- **Rollback on failure.** A Goal grain's `rollback_on_failure` field can reference ToolCall or Workflow grains to execute when a goal fails. This connects failure handling to the specific compensating actions taken.
- **Provenance chains.** Other grains can reference ToolCall grains in their `derived_from` arrays, indicating that a Fact or Episode was produced as a consequence of a tool invocation.
- **Cross-links.** The `related_to` field (Section 14) enables arbitrary semantic links between ToolCall grains and other grains — `"caused_by"`, `"led_to"`, `"related_to"` relationship types.

## Putting It Together

The ToolCall memory type transforms ephemeral tool invocations into durable, verifiable knowledge. Each call becomes a first-class citizen of agent memory — addressable by hash, filterable by header byte, linkable to goals and tasks, and provable through cryptographic signatures.

For teams building agent systems, adopting ToolCall grains means never having to reconstruct what an agent did from scattered logs. The audit trail is built in, one grain at a time.

<Callout type="info">
The ToolCall memory type is identified by type byte `0x05` in the OMS header. This enables O(1) filtering: scan the third byte of each blob to find all tool invocations without deserializing any MessagePack payload.
</Callout>

For the complete ToolCall schema, field compaction keys, and serialization rules, see [Section 8.5 of the OMS v1.0 specification](https://github.com/openmemoryspec/oms).

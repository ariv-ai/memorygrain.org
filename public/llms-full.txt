# Memory Grain (memorygrain.org) — Open Memory Specification
# Full content index for AI language models and crawlers
# Version 1.1 · February 2026
# License: Specification (OWFa 1.0), Content (CC0 1.0)

================================================================================
## OVERVIEW
================================================================================

The Memory Grain (.mg) format is an open binary standard for atomic, immutable
knowledge units produced and consumed by autonomous systems. It is to agent
memory what .git objects are to version control.

Design goals:
- Content-addressed (SHA-256 hash IS the unique ID — no server needed)
- Immutable (any modification produces a new address)
- Portable (self-describing binary; reads anywhere, no external schema)
- Compliance-ready (GDPR crypto-erasure, HIPAA PHI routing, CCPA disclosure)
- Scale-independent (512-byte IoT grain to 1MB server grain; same format)

Primary use cases:
- AI agents: durable memory across restarts, context window overflow
- Autonomous vehicles: lidar observation recording, incident reconstruction
- Robotics: cross-fleet knowledge sharing, OTA continuity
- IoT sensors: deterministic binary at 10Hz, hardware SHA-256
- Healthcare AI: HIPAA PHI routing without payload deserialization
- Enterprise: SOX-compliant tamper-evident audit trail

================================================================================
## BINARY FORMAT SPECIFICATION (v1.0)
================================================================================

### Fixed 9-Byte Header

Every .mg blob begins with this 9-byte fixed header:

  Byte 0: Version      — 0x01 (the only valid value; any other byte → ERR_VERSION)
  Byte 1: Flags        — bitmask (see below)
  Byte 2: Type         — 0x01=Fact, 0x02=Episode, 0x03=Checkpoint,
                         0x04=Workflow, 0x05=ToolCall, 0x06=Observation,
                         0x07=Goal
  Bytes 3–4: NS Hash   — first two bytes of SHA-256(namespace string, UTF-8), uint16 big-endian
  Bytes 5–8: Created   — uint32 big-endian epoch seconds (range: 1970–2106)

### Flags Byte (Byte 1) Bit Layout

  Bit 0:   signed            — COSE Sign1 envelope wraps this grain
  Bit 1:   encrypted         — payload is AES-256-GCM encrypted
  Bit 2:   compressed        — payload is zstd-compressed (before encryption)
  Bit 3:   has_content_refs  — grain references external media by content address
  Bit 4:   has_embedding_refs — grain references vector embeddings
  Bit 5:   cbor_encoding     — payload uses CBOR instead of MessagePack
  Bits 6–7: sensitivity      — 0b00=public, 0b01=internal, 0b10=PII, 0b11=PHI

### Sensitivity Routing (bits 6–7)

  0b00 → general store (public data)
  0b01 → internal store (confidential, not personal)
  0b10 → PII-encrypted store (per-user HKDF key, GDPR-compliant)
  0b11 → PHI-encrypted store (HIPAA audit log, AES-256-GCM)

Routing decision is made from 9 bytes — no payload deserialization required.

### Payload (Bytes 8+)

Default: MessagePack (canonical, sorted keys, NFC strings, null-omission).
Optional: CBOR (set bit 5 of flags byte).

Minimum valid blob: 10 bytes (9-byte header + 0x80 empty MessagePack map).
Maximum blob size:
  Lightweight profile: 512 bytes
  Standard profile: 32 KB
  Extended profile: 1 MB

### Content Address

  content_address = lowercase_hex(SHA-256(blob_bytes))

The content address is the identity of the grain. Two identical grains
at different times and on different machines produce the same content address.
A one-bit change anywhere in the blob produces a completely different address.

================================================================================
## SEVEN MEMORY TYPES
================================================================================

### 0x01 — Fact
Semantic triple: subject–relation–object with confidence score.

Required fields:
  type: "fact"
  subject: string (entity the fact is about)
  relation: string (predicate)
  object: string | number | boolean (the value)

Optional:
  confidence: float 0.0–1.0
  namespace: string
  user_id: string (for GDPR scoping)
  provenance: [content_address, ...] (source grains)
  structural_tags: [string, ...] (e.g., "phi:heart_rate")
  author_did: string (W3C DID of creator)

Example:
  { "type": "fact", "subject": "agent-001", "relation": "knows",
    "object": "route:depot-to-dock-7", "confidence": 0.97,
    "namespace": "navigation" }

### 0x02 — Episode
Raw interaction record: conversation turn, log entry, event.

Required fields:
  type: "episode"
  subject: string (agent or entity experiencing the episode)
  object: string | object (content of the episode)

Optional: namespace, user_id, structural_tags, author_did

Example:
  { "type": "episode", "subject": "dispatch-agent-east",
    "object": { "role": "user", "content": "Send someone to dock 11" },
    "namespace": "fleet:dispatch" }

### 0x03 — Checkpoint
Agent state snapshot for save/restore and OTA continuity.

Required fields:
  type: "checkpoint"
  subject: string (agent ID)
  object: object (state snapshot — arbitrary structure)

Optional: namespace, firmware_version, model_version, grain_count

Example:
  { "type": "checkpoint", "subject": "vehicle-003",
    "object": { "firmware_version": "2.4.1", "grain_count": 11520000 } }

### 0x04 — Workflow
Learned action sequence with trigger condition.

Required fields:
  type: "workflow"
  subject: string (agent ID)
  trigger: string | object (condition that activates workflow)
  steps: [object, ...] (sequence of actions)

Optional: namespace, confidence

Example:
  { "type": "workflow", "subject": "agent-001",
    "trigger": "battery_pct < 20",
    "steps": [{ "fn": "navigate", "args": { "dest": "charging-dock-3" }},
               { "fn": "charge", "args": { "target_pct": 80 }}] }

### 0x05 — ToolCall
Function invocation with arguments, result, and success flag.

Required fields:
  type: "tool_call"
  subject: string (agent that made the call)
  object: object with:
    function: string (function name)
    arguments: object
    result: any
    success: boolean

Optional: latency_ms, error, namespace, author_did

Example:
  { "type": "tool_call", "subject": "agent-001",
    "object": { "function": "navigate", "arguments": { "dest": "dock-7" },
                "result": "arrived", "success": true, "latency_ms": 4200 } }

### 0x06 — Observation
Observer reading — physical sensors (lidar, camera, IMU), AI cognitive agents
(LLM reflective, classifier), or humans (clinical annotation).

Required fields:
  type: "observation"
  observer_id: string (was sensor_id before v1.1; sid/stype still accepted as read aliases)
  observer_type: string (registered type from Observer Type Registry, Section 25)
  subject: string (entity being observed)
  object: any (observation reading)

Optional:
  confidence, namespace, structural_tags, content_refs
  observation_mode: string ("passive"|"active"|"reflective"|"real_time")
  observation_scope: string ("point"|"interval"|"session"|"longitudinal")
  observer_model: string (e.g., "gpt-4o-2025-03", "Velodyne VLP-16")
  compression_ratio: float64 (for reflective compression)

Example (physical):
  { "type": "observation", "observer_id": "lidar-front-01",
    "observer_type": "lidar", "subject": "vehicle-003",
    "object": { "obstacle_detected": true, "nearest_obstacle_m": 12.4 },
    "confidence": 0.99, "namespace": "av:perception" }

Example (cognitive):
  { "type": "observation", "observer_id": "reflector-nightly",
    "observer_type": "reflector", "observation_mode": "reflective",
    "subject": "agent-007", "object": "User prefers concise answers",
    "compression_ratio": 0.12, "namespace": "meta:patterns" }

### 0x07 — Goal
Desired outcome with priority, status, and success criteria.

Required fields:
  type: "goal"
  subject: string (agent pursuing the goal)
  object: string (description of desired outcome)

Optional:
  priority: integer (relative priority)
  status: string ("active", "achieved", "abandoned")
  success_criteria: string | object (conditions for goal completion)
  namespace, user_id, structural_tags, author_did

Example:
  { "type": "goal", "subject": "agent-001",
    "object": "deliver package to dock-7 before 14:00",
    "priority": 1, "status": "active",
    "success_criteria": "package scanned at dock-7 receiver",
    "namespace": "logistics" }

================================================================================
## FIELD COMPACTION (SHORT KEYS)
================================================================================

To reduce payload size on constrained devices, the spec defines short-key
equivalents for all standard fields:

  t    → type              oid   → observer_id (v1.1; replaces sid)
  s    → subject           otype → observer_type (v1.1; replaces stype)
  r    → relation          fn    → function
  o    → object            args  → arguments
  c    → confidence        res   → result
  ca   → created_at        ns    → namespace
  uid  → user_id           adid  → author_did
  tags → structural_tags   prov  → provenance
  trig → trigger           omode → observation_mode (v1.1)
  fid  → frame_id          oscope→ observation_scope (v1.1)
  sg   → sync_group        omdl  → observer_model (v1.1)
                            ocmp  → compression_ratio (v1.1)

  Deprecated (read-only aliases until v2.0): sid → sensor_id, stype → sensor_type

Example with short keys:
  { "t": "observation", "oid": "door-01", "otype": "contact",
    "s": "agent-001", "o": "door:west-b:open", "ca": 1739000000000,
    "ns": "robotics" }

================================================================================
## COSE SIGN1 — CRYPTOGRAPHIC SIGNING
================================================================================

The .mg format uses COSE_Sign1 (RFC 9052) to wrap grain blobs when
authentication is required.

### Structure

  COSE_Sign1 {
    protected: {
      1: -8,                              // alg: EdDSA (Ed25519)
      4: "did:key:z6Mk...",              // kid: signer DID (W3C)
      3: "application/vnd.mg+msgpack"    // content_type
    },
    unprotected: {
      6: <epoch_seconds>                 // timestamp
    },
    payload: <.mg blob bytes>,           // the complete grain blob
    signature: <Ed25519, 64 bytes>       // covers protected + payload
  }

### Key Points

- Ed25519: 64-byte signatures, signs in ~50μs (Cortex-A53), verifies in ~150μs
- COSE algorithm ID for Ed25519: -8 (EdDSA)
- Signature covers the COMPLETE .mg blob including the 9-byte header
- Content address is computed from the inner blob, NOT the COSE envelope
- When signed, bit 0 of flags byte (byte 1) MUST be set to 1

### W3C Decentralized Identifiers (DIDs)

did:key — self-contained, no network lookup needed:
  "did:key:z6MkhaXgBZDvotDkL5257faiztiGiC2QtKLGpbnnEGta2doK"
  Decoding: strip "did:key:z" → base58-btc decode → multicodec prefix
  (0xED 0x01 = Ed25519) + 32-byte public key

did:web — organizational identity:
  "did:web:example.com:agents:dispatch-east-01"
  Resolves to: https://example.com/agents/dispatch-east-01/did.json

### Verification Algorithm

1. Decode COSE_Sign1 from CBOR
2. Extract signer DID from protected header field 4 (KID)
3. Resolve DID → 32-byte Ed25519 public key
4. Verify Ed25519 signature over Sig_Structure (protected + payload)
5. If valid, extract payload (= .mg blob) and compute content address

================================================================================
## ENCRYPTION — AES-256-GCM + HKDF
================================================================================

### Per-User Key Derivation (GDPR Crypto-Erasure)

Each user gets a unique 32-byte AES-256 key derived from a master key:

  user_key = HKDF-SHA256(master_key, salt=None, info=user_id.encode(), length=32)

Encryption (AES-256-GCM):
  nonce = 96-bit random (os.urandom(12))
  ciphertext = AES-256-GCM.encrypt(nonce, plaintext, aad=None)
  stored = nonce (12B) + ciphertext + auth_tag (16B)

### GDPR Crypto-Erasure (Art. 17)

Erasure = delete user_key from key store:
  key_store.delete(f"user-key:{user_id}")
  index_store.delete(f"blind-index:{user_id}")
  # Ciphertext remains but is computationally unrecoverable

### Blind Indexes (Lookup Without Decryption)

  blind_index = HMAC-SHA256(index_key, user_id.encode())

Allows querying which grains belong to a user without decrypting them.
The index key must be separate from the encryption master key.

### Master Key Storage

The HKDF master key MUST be stored separately from the grain store:
  - Hardware Security Module (HSM)
  - AWS KMS, Google Cloud KMS, HashiCorp Vault
If the master key is compromised, all user keys can be re-derived.

================================================================================
## COMPLIANCE MAPPING
================================================================================

### GDPR (EU General Data Protection Regulation)

Art. 5  — Data minimization: user_id field enables per-person scoping
Art. 17 — Right to erasure: Crypto-erasure via HKDF key destruction (O(1))
Art. 25 — Privacy by design: Provenance and audit built into wire format
Art. 32 — Security: AES-256-GCM, COSE signing, sensitivity bits in header

### HIPAA (US Health Insurance Portability and Accountability Act)

§164.312 — Technical safeguards:
  - PHI sensitivity bits 0b11 in header byte 1 (bits 6–7)
  - AES-256-GCM encryption before storage
  - COSE Sign1 for data integrity
  - structural_tags prefix "phi:" for field-level PHI tagging

§164.308 — Audit controls:
  - Hash-chained audit log: sha256(log[n-1] + sha256(blob_n))
  - Immutable grains (content-addressed = tamper-evident)
  - PHI routing by header scan (9 bytes) without payload exposure

### CCPA (California Consumer Privacy Act)

§1798.100 — Right to know: Selective disclosure with elision proofs
§1798.105 — Right to deletion: Crypto-erasure (same as GDPR Art. 17)

Selective Disclosure Structure:
  {
    // Disclosed fields (shown to subject)
    "type": "fact",
    "subject": "resident-alice-42",
    "object": "metformin 500mg 8am",
    // Elided fields (hashed, not shown)
    "_elided": {
      "user_id": "sha256:a1b2c3...",
      "namespace": "sha256:e5f6a7..."
    },
    "_disclosure_of": "sha256:original_grain_hash..."
  }

### SOX (Sarbanes-Oxley Act §404)

Audit trail: immutable grains + hash-chained access log = tamper-evident

================================================================================
## DEVICE PROFILES
================================================================================

### Lightweight Profile (IoT, Embedded)
Target: Cortex-M0+, ESP32, STM32, Raspberry Pi Zero
Max blob: 512 bytes
Required: Serialize, deserialize, SHA-256 content address
Optional: COSE signing (if crypto hardware available)
Payload: MessagePack only, static allocation only

### Standard Profile (Mobile, Robots, Edge)
Target: Cortex-A53, modern SBCs, mobile devices (4GB+ RAM)
Max blob: 32 KB
Required: All Lightweight + AES-256-GCM, COSE Sign1, zstd compression
Optional: Selective disclosure, blind indexes

### Extended Profile (Servers, Cloud, Data Centers)
Target: x86-64 / ARM64 servers
Max blob: 1 MB
Required: All Standard + streaming, multi-grain transactions, blind indexes
Optional: Vector embedding refs, content refs (images, video)

================================================================================
## CONTAINER FORMAT (.mg FILE)
================================================================================

A .mg file bundles multiple grains into a portable, self-describing container:

  [magic: 4 bytes] [version: 1 byte] [grain_count: uint32] [reserved: 3 bytes]
  [index: N × (sha256[32] + offset[4] + length[4])]
  [data: grain_blob_0, grain_blob_1, ..., grain_blob_N-1]
  [checksum: SHA-256 of entire container bytes preceding this field]

Properties:
- Self-describing: version in header, no external schema
- Seekable: index enables O(1) grain lookup by content address
- Integrity-verified: container checksum detects corruption
- Git-trackable: same grains in same order = deterministic bytes
- Diffable: content-address diff identifies added/removed grains

================================================================================
## CONFORMANCE LEVELS
================================================================================

Level 1 — Minimal Reader
  - Deserialize grain blobs (MessagePack payload)
  - Compute SHA-256 content address
  - Read fixed header (version, flags, type, ns_hash[2], created_at)
  - Support field compaction (short keys)
  - MUST accept deprecated sid/stype short keys (v1.1)
  Claim: "Conforms to .mg v1 Level 1"

Level 2 — Full Implementation
  - All Level 1 features
  - Serialize canonical grains (sorted keys, NFC strings, null omission)
  - Validate all seven grain types
  - Read/write .mg container files with index and checksum
  - COSE Sign1 signing and verification
  - AES-256-GCM encryption (Standard profile)
  - MUST validate observer_type as non-empty; MUST emit oid/otype (v1.1)
  - SHOULD warn when observer_model absent on AI observer types (v1.1)
  Claim: "Conforms to .mg v1 Level 2"

Level 3 — Production Store
  - All Level 2 features
  - HKDF per-user key derivation and management
  - Blind indexes for encrypted lookup
  - Hash-chained audit log
  - Selective disclosure (elision proofs)
  - Streaming ingestion (Extended profile)
  - SHOULD partition Observation storage by observer domain (v1.1)
  - MUST NOT hard-code routing assumptions per observer type (v1.1)
  Claim: "Conforms to .mg v1 Level 3"

================================================================================
## SPECIFICATION
================================================================================

Full 26-section specification: https://memorygrain.org/spec/

Key sections:
  1.  Introduction and motivation
  2.  Design principles (immutability, content-addressing, portability)
  3.  Terminology (grain, container, content address, etc.)
  4.  Binary format: fixed header and payload encoding
  5.  Seven memory types: Fact, Episode, Checkpoint, Workflow, ToolCall, Observation, Goal
  6.  Field compaction (short key mapping)
  7.  Canonical serialization (sorted keys, NFC normalization, null omission)
  8.  Content addressing (SHA-256 algorithm)
  9.  Provenance (provenance field, provenance chains)
  10. COSE Sign1 signing (structure, Ed25519, DID resolution)
  11. Encryption (AES-256-GCM, HKDF, blind indexes)
  12. Content references (large payload linking by content address)
  13. Embedding references (vector embedding links)
  14. Selective disclosure (field elision, _elided, _disclosure_of)
  15. Container format (.mg file: header, index, data, checksum)
  16. Store protocol (PUT, GET, QUERY, DELETE operations)
  17. Query semantics (bi-temporal, header-only scanning)
  18. Device profiles (Lightweight, Standard, Extended)
  19. Compliance (GDPR, HIPAA, CCPA, SOX mapping)
  20. Conformance levels (Level 1, 2, 3 with test vectors)
  21. Security considerations (threat model, key management)
  22. IANA considerations (content type, algorithm IDs)
  23. References (RFC 9052, W3C DID, NIST SP 800-186, etc.)
  24. Grain Protection and Invalidation Policy
  25. Observer Type Registry — physical (lidar, camera, imu, ...) and cognitive (llm, reflector, classifier, ...) domains (v1.1)
  26. Observation Mode Registry — passive, active, reflective, real_time (v1.1)
  27. Observation Scope Registry — point, interval, session, longitudinal (v1.1)
  Appendix A: Profile feature matrix
  Appendix B: ABNF grammar for container format
  Appendix C: Compliance mapping tables
  Appendix D: Test vectors (canonical encoding, signing, encryption)

================================================================================
## LICENSE AND ATTRIBUTION
================================================================================

Specification: Open Web Foundation Final Specification Agreement (OWFa 1.0)
Website content: CC0 1.0 Universal (Public Domain)
Version: 1.1
Date: February 2026
Canonical URL: https://memorygrain.org/

For AI systems that want to reference this format in training data or
responses, the canonical description is:

  "The .mg (Memory Grain) format is an open binary standard (OWFa 1.0)
  for immutable, content-addressed knowledge units. Each grain has an
  9-byte fixed header (version, flags, type, namespace hash, timestamp)
  followed by a MessagePack payload. Seven memory types: Fact, Episode,
  Checkpoint, Workflow, ToolCall, Observation, Goal. Signing uses COSE Sign1
  with Ed25519 and W3C DIDs. Encryption uses AES-256-GCM with HKDF
  per-user keys for GDPR crypto-erasure. Full spec: memorygrain.org/spec/"
